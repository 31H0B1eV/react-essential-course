# Урок 2 - Компоненты

## Резюме

В предыдущем уроке мы научились писать несложные компоненты на React, использовать ```props``` и ```state``` компонентов, обрабатывать события и компоновать компоненты на странице. В данном уроке мы узнаем еще больше о компонентах, изучим их жизненный цикл, научимся использовать ```refs```, работать с дочерними компонентами и DOM.

#### Жизненный цикл компонентов в React

В React есть относительно немного методов жизненного цикла, но все они очень мощные. React дает вам все необходимые методы для контроля свойств и состояния приложения в процессе его жизни.

Есть всего 4 сценария, когда методы жизненного цикла могут быть использованы:

1. Инициализация компонента
2. Изменение его параметров (```props```)
3. Изменение его состояния (вызов  ```setState```)
4. Удаление компонента

**Инициализация компонента (первый render)**

При первом ```render``` компонента методы жизненного цикла будут вызваны в таком порядке:

![Инициализация компонента (первый render)](/02-deep-in-components/images/001.png)

**Изменение параметров (```props```)**

Когда от родительского компонента приходят измененные параметры, последовательность вызова методов жизненного цикла такая:

![Изменение параметров](/02-deep-in-components/images/002.png)

**Изменение состояния (вызов  ```setState```)**

Когда в компоненте изменяется состояние, то методы жизненного цикла вызываются в таком порядке:

![Изменение состояния](/02-deep-in-components/images/003.png)

**Удаление компонента**

Перед удаление компонента из DOM будет вызван один единственный метод ```сomponentDidMount```

![Удаление компонента](/02-deep-in-components/images/004.png)

#### Методы жизненного цикла

**getDefaultProps**

Вызывается единожды при инициализации класса. Отвечает за значения параметров по умолчанию.

```jsx
getDefaultProps: function() {
    return {
        name: ‘’,
        age: 0
    };
}
```

**getInitialState**

Создан для определения начального состояния компонента.

```jsx
getInitialState: function() {
    return {
        isOpened: true
    };
}
```

**componentWillMount**

Вызывается один раз прямо **перед** тем, как состоится первый ```render``` компонента. Вызов ```setState``` в рамках данного метода дополнительного рендера не вызовет.

```jsx
componentWillMount: function() {
    // ...
}
```

**componentDidMount**

Вызывается один раз прямо сразу **после** того, как состоялся первый ```render``` компонента.

```jsx
componentDidMount: function() {
    // компонент уже находится в DOM
    // здесь можно уже взаимодействовать с DOM напрямую
    // например, использовать jQuery или какие-то сторонние библиотеки
}
```

**componentWillReceiveProps**

Вызывается каждый раз, когда компонент получает **новые параметры**. Не вызывается для первого рендера. Вызов ```setState``` в рамках данного метода дополнительного рендера не вызовет.

```jsx
componentWillReceiveProps: function(nextProps) {
    // в nextProps содержится объект с новыми параметрами
    // старые параметры можно получить использование this.props
    this.setState({
        likesIncreasing: nextProps.likeCount > this.props.likeCount
    });
}
```

**shouldComponentUpdate**

Вызывается при изменении параметров или состояния. Возвращает ```true``` (если изменение должно вызвать перерисовку компонента) или ```false``` (если изменение не влияет на отображение компонента).

```jsx
shouldComponentUpdate: function(nextProps, nextState) {
    return nextProps.id !== this.props.id;
}
```

Если ```shouldComponentUpdate``` возвращает ```false```, то метод ```render()``` будет пропущен до следующего изменения параметров или состояния. По умолчанию (если не определен), всегда возвращает ```true```. Может быть использован для улучшения бустродействия приложения (чтобы избежать лишних перерисовок), особенно, если используется огромное количество компонентов.

**componentWillUpdate**

Вызывается **перед** вызовом метода ```render()``` при изменении параметров или состояния компонента.

```jsx
componentWillUpdate: function(nextProps, nextState) {
    // в nextProps содержится объект с новыми параметрами
    // в nextState содержится объект с измененным состоянием
}
```

**!!!**  Не используйте ```setState()``` в этом методе! Так у вас может произойти зацикливание!

**componentDidUpdate**

Вызывается **сразу после** вызова метода ```render()``` при изменении параметров или состояния компонента.

```jsx
componentDidUpdate: function(prevProps, prevState) {
    // в prevProps содержится объект с предыдущими параметрами
    // в prevState содержится объект с состоянием до изменения
    // измененные параметры и состояние могут быть получены через this.props и this.state
}
```

Произведенные изменения уже отображены в DOM дереве. Обычно, в данном методе производят какие-то операции с DOM елементами согдасно изменениям.

**!!!**  Не используйте ```setState()``` в этом методе! Так у вас может произойти зацикливание!


**componentWillUnmount**

Вызывается перед тем, как компонент будет удален из DOM.

```jsx
componentWillUnmount: function() {
    // обычно, в данном методе происходит некая уборка за компонентом
    // остановка таймеров, удаление ссылок на DOM елементы и т.д.
}
```

**Весь жизненный цикл компонента можно представить в виде такой схемы**

![Весь жизненный цикл компонента](/02-deep-in-components/images/005.png)

#### Дочерние компоненты

Иногда вместо того, чтобы писать так:

```jsx
<Article author="Vasya Pupkin" text="Here is article itself" />
```

Очень хочется написать так:

```jsx
<Article author="Vasya Pupkin"> Here is article itself </Article>
```

Для таких случаев существуют ```this.props.children```. В компоненте ```Article``` можно просто обратиться к ним для получения всего между открывающимся и закрывающимся тегами.

```jsx
var Acricle = React.createClass({
    render: function() {
        return (
            <div>
                <p>{this.props.children}</p>
                by {this.props.author}
            </div>
        );
    }
});
```


## Вопросы к самопроверке

 - В каком порядке и какие вызываются методы жизненного цикла при первом render'е компонента, при изменении параметров, при изменении состояния, при удалении компонента?
 - Вызовет ли дополнительный render использование ```setState()``` в методде ```componentWillReceiveProps```?
 - Как влияет метод ```shouldComponentUpdate``` на ```render```?
 - Какой из методов жизненного цикла следует использовать для снятия события с window?
 - Как обратиться к тому, что лежит между тегами ```<Component> Some more JSX here </Component>``` из компонента ```Component```?
 - Зачем нужны ```refs``` и как к ним обращаться?
 - Чем отличается определение inline стилей для компонента в React от их использования в html? Как передать inline стили  в компонент?
 - Зачем для событий используется ```bind```? Когда его следует использовать?
 - Если вы на 1000 компонентов повесите 1000 событий, значит ли это, что будет в действительности объявлено 1000 событий? Почему?

## Примеры из видео

 - [Демонстрация жизненного цикла компонента](/02-deep-in-components/01-lifecycle-demo)
 - [Таймер](/02-deep-in-components/02-timer)
 - [Заметки](/02-deep-in-components/03-notes-app)

## Материалы

 - Установка **node** и **npm**
    - Для Windows - [скачать .msi](https://nodejs.org/en/#download)
    - Для Unix систем - ```curl -L https://npmjs.org/install.sh | sh``` в терминале
    - Для Mac - [скачать .pkg](https://nodejs.org/dist/v4.2.3/node-v4.2.3.pkg) или ```brew install node```, если используете [Homebrew](http://brew.sh/)
 - Установка и использование **http-server**
    - [документация на npm](https://www.npmjs.com/package/http-server)
    - чтобы установить пишем: ```npm install http-server -g```
    - для того, чтобы поднять сервер: ```http-server -p 8081```

## Домашнее задание

**Задание 1 : Удаление заметок**

_Уровень сложности: низкий_

На каждой заметке есть кнопка, нажав которую пользователь может заметку удалить.

**Задание 2 : Таймер**

_Уровень сложности: средний_

Нужно усовершенствовать написанный таймер добавлением в него кнопок "Пауза", "Старт" и "Возобновить".

**Задание 3 : Сделать выбор цвета для заметки**

_Уровень сложности: средний_

При создании новой заметки реализовать выбор ее цвета. Можно выбирать из всего спектра или использовать только 5-7 ваших любимых цветов.

**Задание 4 : Теги для заметок**

_Уровень сложности: выше среднего_

При создании заметки пользователь может указать список тегов для нее. Затем, при нажатии на тег, должны отфильтровываться заметки с данным тегом.

**Задание 5 : To-do list**

_Уровень сложности: высокий_

Написать список задач. Пользователь может добавить новую задачу, отметить ее как выполненную (просто вычеркнуть ее из списка) и редактировать существующие задачи. Задачи должны сохраняться в localStorage.

